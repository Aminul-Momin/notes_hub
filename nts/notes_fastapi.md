-   [FastAPI](https://fastapi.tiangolo.com/)

```python
# ============================================================================
# /app/routers/*.py
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from sqlalchemy import insert, select, update, delete

from fastapi.security.oauth2 import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from sqlalchemy import func
from .. import database, schemas, models, utils, oauth2
from ..database import get_db

# ============================================================================
# /app/models/*.py
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import INTEGER, VARCHAR, Column, TIMESTAMP, func

# ============================================================================
# /app/schemas/*.py
from pydantic import BaseModel, constr

```

---

<details><summary style="font-size:20px;color:Orange;text-align:left">Alembic</summary>

-   [Alembicâ€™s documentation](https://alembic.sqlalchemy.org/en/latest/)
-   [Tutorial: Intro to Database Migrations with Alembic](https://www.youtube.com/watch?v=SdcH6IEi6nE)

-   `Alembic`: In the context of Python, Alembic is an open-source database migration tool that is commonly used with SQLAlchemy, a popular Object Relational Mapping (ORM) library. Alembic helps developers manage database schema changes and versioning in a systematic and organized way.

-   `Key Features and Concepts`:

    -   `Database Migrations`: Alembic allows developers to create and manage database migrations, which are scripts that define changes to the database schema over time. These migrations capture alterations such as adding new tables, modifying columns, or creating indexes.

    -   `Versioning`: Alembic maintains a version history of the database schema by creating and tracking migration files. Each migration file corresponds to a specific version of the schema. This versioning ensures that database changes can be applied in a controlled and predictable manner.

    -   `Command-Line Interface`: Alembic provides a command-line interface (CLI) that allows developers to create, apply, and manage migrations using simple commands. This interface simplifies the process of creating and managing migration scripts.

    -   `Migration Scripts`: Migration scripts are Python scripts generated by Alembic that define database changes. These scripts include instructions to alter the schema, such as creating tables, modifying columns, and adding constraints.

    -   `Migration Upgrades and Downgrades`: Alembic supports both upgrade and downgrade migrations. An upgrade migrates the database schema to a higher version, while a downgrade reverts the schema to a lower version. This helps in rolling back changes if necessary.

    -   `Automated Generation`: Alembic can automatically generate migration scripts based on the changes made to the SQLAlchemy models. It analyzes the differences between the current database schema and the desired schema based on the models and generates migration scripts accordingly.

    -   `Customization`: Developers can customize migration scripts by adding custom SQL commands or Python code to perform complex migrations that may not be automatically detected.

    -   `Integration with SQLAlchemy`: Alembic is designed to work seamlessly with SQLAlchemy, allowing developers to manage database schema changes alongside their SQLAlchemy models.

    -   `Version Control Integration`: Migration scripts can be stored in version control systems (e.g., Git) along with the application code, enabling collaborative development and ensuring a history of schema changes.

    -   `Cross-Database Support`: Alembic supports multiple database backends, enabling developers to work with different database systems while using the same migration tool.

    -   `Documentation and Support`: Alembic provides comprehensive documentation and a supportive community, making it easier for developers to learn and use the tool effectively.

-   Conclusion: Alembic is a powerful and versatile tool for managing database migrations in Python projects. It helps developers maintain a structured approach to evolving the database schema over time, while its integration with SQLAlchemy ensures consistency between application code and the database structure.

</details>

---

<details><summary style="font-size:20px;color:Orange;text-align:left">Pydentic</summary>

-   [Documentation](https://docs.pydantic.dev/latest/)
-   [API Documentation](https://docs.pydantic.dev/latest/api/base_model/)

-   `Pydentic`:Pydantic is a Python library that provides data validation and settings management using Python type annotations. It's particularly useful for validating and parsing data, such as JSON payloads or configuration settings, based on defined models with type hints and validation rules. Pydantic helps ensure data consistency, integrity, and accurate parsing while working with complex data structures.

-   `Key features of Pydantic`:

    -   `Data Validation`: Pydantic uses type hints and validation rules to validate data, ensuring that it conforms to the expected structure and constraints.

    -   `Parsing`: It can automatically parse and convert incoming data, such as JSON, into Python objects that adhere to the defined model.

    -   `Settings Management`: Pydantic is commonly used to manage application settings by defining a settings model with default values, types, and validation rules.

    -   `Customization`: It allows customization of validation rules, error messages, and default values for different fields.

    -   `Complex Types`: Pydantic supports complex data types, including nested models, lists, dictionaries, and more.

    -   `API Request and Response Validation`: It's often used in web applications to validate incoming API requests and format API responses.

    -   `Data Serialization`: Pydantic can serialize data back to JSON or other formats based on the defined model.

    -   `Type Conversion`: It performs automatic type conversion for basic data types, ensuring data consistency.

    -   `Integration with Frameworks`: Pydantic can be integrated with web frameworks like FastAPI to streamline input validation and serialization.

-   Here's a simple example of using Pydantic to define a data model for validating and parsing user data:

    ```python
    from pydantic import BaseModel

    class User(BaseModel):
        username: str
        email: str

    #======================
    data = {
        "username": "john_doe",
        "email": "john@example.com"
    }

    user = User(**data)  # Validation and parsing
    print(user.username)  # Output: john_doe
    ```

-   `Conclusion`: Pydantic is a valuable library in the Python ecosystem that ensures data integrity, simplifies data validation, and streamlines the process of parsing and working with structured data. It's commonly used in various scenarios, including web applications, configuration management, and data transformation.

</details>

---

<details><summary style="font-size:20px;color:Orange;text-align:left">SQLAlchemy</summary>

-   [FastAPI - using SQLAlchemy for DB queries [part - 1]](https://www.youtube.com/watch?v=6RrwKDGKcxM)

-   [SQLAlchemy Datatype Objects](https://docs.sqlalchemy.org/en/20/core/types.html)
-   [class sqlalchemy.schema.Column](https://docs.sqlalchemy.org/en/20/core/metadata.html#sqlalchemy.schema.Column)
-   [Field Data Types](https://docs.sqlalchemy.org/en/20/core/type_basics.html)

-   Architecture:

    -   `SQLAlchemy Library`: At the top level, SQLAlchemy is a Python library that provides tools for working with relational databases.

    -   `Core Components`:

        -   The Core provides a low-level abstraction over databases and SQL. It includes components for constructing and executing SQL expressions, managing connections, transactions, and more.
        -   The Core components include elements for constructing SQL expressions and interacting with databases.

        -   `SQL Expression Language`: This part of the Core allows you to define SQL statements using Python objects and methods. It includes clauses, operators, functions, and more.

        -   `Engine`: The Engine is responsible for managing database connections and executing SQL statements. It includes connection pooling, transaction management, and supports multiple database dialects.

    -   `ORM Components`:

        -   The ORM layer builds on top of the Core and provides a high-level interface for mapping Python classes to database tables. It includes components for defining and querying models, relationships, sessions, and transactions.
        -   The ORM layer provides a higher-level interface for working with databases using Python classes and objects.

        -   `Model Classes`: Model classes represent Python objects that map to database tables. They define attributes, relationships, and metadata.

        -   `Mapping Configuration`: The mapping configuration specifies how Python classes and attributes are mapped to database tables and columns.

        -   `Session`: The Session class manages interactions with the database, including creating, updating, and deleting records. It also provides transactional capabilities.

        -   `Query API`: The Query class allows you to build and execute database queries using Python methods and attributes. It supports filtering, joining, ordering, and aggregating data.

        -   `Relationships`: SQLAlchemy supports defining relationships between model classes, such as one-to-one, one-to-many, and many-to-many relationships.

    -   `Metadata and Reflection`: Metadata represents the structure of the database and is used to define tables, constraints, and other schema elements. Reflection allows you to introspect existing databases to automatically generate model classes.

    -   `SQL Dialects`: SQLAlchemy supports multiple database backends by generating appropriate SQL syntax for each dialect.

    -   `Extensions and Plugins`: SQLAlchemy's modular architecture allows for extensions and plugins to add additional functionality, such as validation, caching, and more.

    -   In summary, the SQLAlchemy architecture consists of the Core and ORM layers. The Core provides tools for constructing and executing SQL expressions, while the ORM layer provides a high-level interface for mapping Python classes to database tables, managing sessions, and querying data. The architecture's modular design and well-defined components make it a powerful and flexible library for working with relational databases in Python.

### How to perform `JOIN` operation?

-   `Using join() Method (as previously shown)`:

    -   This is the most straightforward way to perform JOIN operations in SQLAlchemy.
    -   It allows you to specify the join condition explicitly.

    ```python

    # Perform an INNER JOIN between User and Address models
    query = session.query(User, Address).join(Address, User.user_id == Address.user_id)

    # Fetch the result of the join operation
    results = query.all()

    # Print the results
    for user, address in results:
        print(f"User: {user.name}, Address: {address.street}, {address.city}")
    ```

-   `Using Relationship Attributes`:

    -   If you have defined relationships between your SQLAlchemy models (e.g., using relationship()), you can access related data directly through these relationships.

    ```python
    # Assuming a one-to-many relationship between User and Address
    user = session.query(User).filter_by(username='john').first()
    addresses = user.addresses
    ```

    -   SQLAlchemy will automatically generate the appropriate JOIN query behind the scenes.

-   `Using select_from() Method`:

    -   You can use the `select_from()` method to specify the source tables for your query explicitly.

    ```python
    query = session.query(User, Address).select_from(User).join(Address, User.user_id == Address.user_id)
    ```

-   `Using Aliases`:

    -   You can create aliases for your tables and perform joins with aliases, which can be useful for complex queries.

    ```python
    from sqlalchemy.orm import aliased

    user_alias = aliased(User)
    address_alias = aliased(Address)

    query = session.query(User, Address).\
        join(address_alias, User.user_id == address_alias.user_id)
    ```

-   `Using Raw SQL`:

    -   In some cases, you may need to use raw SQL for complex queries.

    ```python
    from sqlalchemy.sql import text

    sql = text("SELECT * FROM user JOIN address ON user.user_id = address.user_id")
    result = session.execute(sql)
    ```

    -   Use this approach with caution, as it may not be as database-agnostic as other SQLAlchemy methods.

---

<details><summary style="font-size:15px;color:Orange;text-align:left">SQLAlchemy query methods</summary>

-   `query()`: This method is the starting point for creating a query.

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Define the model
Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = Column(String)
    email = Column(String)

# Create the engine and session
engine = create_engine('sqlite:///example.db')
Session = sessionmaker(bind=engine)
session = Session()

# Example of using query methods on model object
user = session.query(User).filter_by(username='alice').first()
print(user.username, user.email)

session.close()
```

-   `filter()`: Adds filtering conditions to the query.

```python
# Filtering users with age greater than 25
users = session.query(User).filter(User.age > 25).all()
```

-   `filter_by()`: Similar to filter(), but uses keyword arguments for filtering conditions.

```python
# Filtering users with name 'Alice'
users = session.query(User).filter_by(name='Alice').all()
```

-   `join()`: Creates a SQL JOIN operation between tables.

```python
from sqlalchemy.orm import joinedload

# Joining User and Address tables
users_with_addresses = session.query(User).join(Address).all()
```

-   `outerjoin()`: Creates an OUTER JOIN operation between tables.

```python
# Outer joining User and Address tables
users_with_optional_addresses = session.query(User).outerjoin(Address).all()
```

-   `group_by()`: Groups the results based on specified columns.

```python
from sqlalchemy import func

# Grouping users by age and counting
age_group_counts = session.query(User.age, func.count()).group_by(User.age).all()
```

-   `order_by()`: Specifies the order in which the results should be sorted.

```python
# Ordering users by name in descending order
users_ordered_by_name = session.query(User).order_by(User.name.desc()).all()
```

-   `limit()`: Limits the number of results returned by the query.

```python
# Limiting to retrieve only 5 users
limited_users = session.query(User).limit(5).all()
```

-   `offset()`: Skips a certain number of results before starting to fetch.

```python
# Retrieving users after skipping the first 10
users_after_offset = session.query(User).offset(10).all()
```

-   `distinct()`: Applies the DISTINCT keyword to the query.

```python
# Retrieving distinct age values
distinct_ages = session.query(User.age).distinct().all()
```

-   `count()`: Returns the count of rows matching the query.

```python
# Counting the number of users
user_count = session.query(User).count()
```

-   `first()`: Returns the first result of the query.

```python
# Retrieving the first user
first_user = session.query(User).first()
```

-   `all()`: Returns all results of the query.

```python
# Retrieving all users
all_users = session.query(User).all()
```

-   `scalar()`: Returns the first column of the first result as a scalar value.

```python
# Retrieving the scalar value of the first user's age
first_user_age = session.query(User.age).first()
```

-   `exists()`: Returns a boolean indicating whether any results exist for the query.

```python
# Checking if there are any users with age greater than 30
users_exist = session.query(User).filter(User.age > 30).exists()
```

-   `subquery()`: Returns a subquery representing the current query.

```python
# Using a subquery to retrieve addresses of users older than 25
subq = session.query(Address.user_id).filter(User.age > 25).subquery()
addresses = session.query(Address).filter(Address.user_id.in_(subq)).all()
```

-   `from_self()`: Returns a new Query object with the same options as the current query.

```python
# Creating a new query from an existing query
new_query = session.query(User).from_self()
```

-   `get()`: Retrieves a row by its primary key value.

```python
# Retrieving a user by primary key
user = session.query(User).get(1)
```

-   `delete()`: Generates a DELETE statement based on the query and deletes matching rows.

```python
# Deleting users with age less than 25
session.query(User).filter(User.age < 25).delete()
```

-   `update()`: Generates an UPDATE statement based on the query and updates matching rows.

```python
# Updating age of users named 'Alice'
session.query(User).filter_by(name='Alice').update({'age': 28})
```

-   `union()`: Creates a union of two or more queries.

```python
# Creating a union of two queries
union_query = session.query(User).filter(User.age < 30).union(session.query(User).filter(User.age > 40))
```

-   `intersect()`: Creates an intersection of two or more queries.

```python
# Creating an intersection of two queries
intersection_query = session.query(User).filter(User.age < 30).intersect(session.query(User).filter(User.age > 20))
```

-   `except_()`: Creates a difference between two queries.

```python
# Creating a difference between two queries
difference_query = session.query(User).filter(User.age < 30).except_(session.query(User).filter(User.age < 25))
```

-   These are some of the many query methods provided by SQLAlchemy's Query API. Keep in mind that this is a simplified demonstration, and you can combine and customize these methods to build complex and efficient queries for your database interactions. For more comprehensive information and examples, refer to the official SQLAlchemy documentation.
</details>
</details>
